# Runs the main method for all years between 2002 and 2016
multiYearResults <- function() {
    L <- c()
    tot <- 0
    for (year in 2002:2016) {
        temp <- main(year, 4)
        L[length(L) + 1] <- temp
        tot <- tot + temp
        print(year)
        print(temp)
    }
    print(L)
    print(tot)
    tot
}


# Generates the ranking for the given year, taking into account all games up to the bowl games
# Given the ranking, counts how many bowl games the model correctly predicted that year
# Param t: The number of previous years the model is using for its training set
# Returns the number of Bowl games correctly predicted.

main <- function(year, t) {
    rM <- matrix(rep(0, 603), nrow = 201, ncol = 3)
    using2020 <- FALSE
    for (y in 1:t) {
        cgYear <- year - 1
        if (cgYear == 2020) {
            using2020 <- TRUE
        }
        if (using2020) {
            cgYear <- cgYear - 1
        }
        rM <- rM + gen_rM(cgYear)
    }
    x <- 4
    B <- dataC(rM)
    LR2 <- glm(B[, 2] ~ B[, 1], family = "binomial")
    summary(LR2)
    b <- coefficients(LR2)[1]
    a <- coefficients(LR2)[2]
    h <- homeAd(-20, 20, a, b)
    getSpreads(year, a, b, h)
}


# Given a logistic function, f(x), finds the h such f(h) = .5, within an error of .0001
# param A, B: The inital bounds of where we are certain h must fall between
# param a, b: The parameters of the logistic function. f(x) = 1/(1 + exp(-(ax +b)))
# returns h

homeAd <- function(A, B, a, b) {
    C <- (B + A) / 2
    if (abs(logR(C, a, b) - .5) < .0001) {
        return(C)
    }
    if (logR(C, a, b) > .5) {
        return(homeAd(A, C, a, b))
    } else {
        return(homeAd(C, B, a, b))
    }
}

# given a Table, A, generated from a csv file of game data, and the row index, i, we want to get the Winner from,
# returns the name of the Winner of that game. If the team has a ranking before it, this method removes the ranking
# param A: A table generated by the csv file of game data
# param i: The row index we want to get the winner from
# returns the name of the winning team, without any ranking before it

getWinner <- function(A, i) {
    if (substr(A[i, 5], 1, 1) == "(" && substr(A[i, 5], 3, 3) == ")") {
        k <- A[i, 5]
        nameW <- substr(k, 5, nchar(k))
    } else if (substr(A[i, 5], 1, 1) == "(" && substr(A[i, 5], 4, 4) == ")") {
        k <- A[i, 5]
        nameW <- substr(k, 6, nchar(k))
    } else {
        nameW <- A[i, 5]
    }
    nameW
}

# given a Table, A, generated from a csv file of game data, and the row index, i, we want to get the Loser from,
# returns the name of the Loser of that game. If the team has a ranking before it, this method removes the ranking
# param A: A table generated by the csv file of game data
# param i: The row index we want to get the loser from
# returns the name of the losing team, without any ranking before it

getLoser <- function(A, i) {
    if (substr(A[i, 8], 1, 1) == "(" && substr(A[i, 8], 3, 3) == ")") {
        k <- A[i, 8]
        nameL <- substr(k, 5, nchar(k))
    } else if (substr(A[i, 8], 1, 1) == "(" && substr(A[i, 8], 4, 4) == ")") {
        k <- A[i, 8]
        nameL <- substr(k, 6, nchar(k))
    } else {
        nameL <- A[i, 8]
    }
    nameL
}

# For a given year, generates rM, a matrix reflecting the common game results
# rM is a 201 x 3 matrix, each row represents a margin of victory, row i represents a team winning by (i -101) points
# Looks at the CG file previously generated (see genCG) and looks at all games with a margin of victory of (i - 101)
# For every game with that margin of vitory, it looks at every common team game played
# For every common team game that the original home team wins, column 1 of row i-101 increases by 1
# For every common team game that the original away team wins, column 2 of row i-101 increases by 1
# For every common team game played, column 3 increases by 1

# param year: the year of the season we are generating rM for
# returns rM: a matrix reflecting the common game results for a given margin of victory

gen_rM <- function(year) {
    P <- read.csv(file = paste("CG", year, ".csv", sep = ""), head = TRUE, sep = ",")
    i <- 1
    rM <- matrix(rep(0, 603), nrow = 201, ncol = 3)
    while (i < NROW(P)) {
        if (P[i, 2] != 0) {
            homeS <- strsplit(P[i, 6], " ")
            awayS <- strsplit(P[i, 7], " ")
            j <- 2
            while (j < length(homeS[[1]])) {
                if (homeS[[1]][j] == "H" && as.numeric(homeS[[1]][j + 1]) > 0 ||
                    homeS[[1]][j] == "A" && as.numeric(homeS[[1]][j + 1]) < 0) {
                    rM[P[i, 4] + 101, 1] <- rM[P[i, 4] + 101, 1] + 1
                    rM[P[i, 4] + 101, 3] <- rM[P[i, 4] + 101, 3] + 1
                } else {
                    rM[P[i, 4] + 101, 2] <- rM[P[i, 4] + 101, 2] + 1
                    rM[P[i, 4] + 101, 3] <- rM[P[i, 4] + 101, 3] + 1
                }
                if (awayS[[1]][j] == "H" && as.numeric(awayS[[1]][j + 1]) > 0 ||
                    awayS[[1]][j] == "A" && as.numeric(awayS[[1]][j + 1]) < 0) {
                    rM[P[i, 4] + 101, 2] <- rM[P[i, 4] + 101, 2] + 1
                    rM[P[i, 4] + 101, 3] <- rM[P[i, 4] + 101, 3] + 1
                } else {
                    rM[P[i, 4] + 101, 1] <- rM[P[i, 4] + 101, 1] + 1
                    rM[P[i, 4] + 101, 3] <- rM[P[i, 4] + 101, 3] + 1
                }

                j <- j + 2
            }
        }
        i <- i + 1
    }
    rM
}

# tranforms rM into a matrix we can take perform a logistic regression on
# for every common game played, column 1 records the original margin of victory and column 2 records either a 0 or 1
# if the original home team wins a common game, a 1 is added to column 2; if they lose a 0 is added
# if the original away team wins a common game, a 0 is added to column 2; if they lose a 1 is added

# param: rM, a matrix reflecting the common game results for a given margin of victory
# returns: A, a tranformation of rM that logistic regression can be performed on

dataC <- function(rM) {
    k <- 1
    numG <- 0
    while (k < 202) {
        numG <- numG + rM[k, 3]
        k <- k + 1
    }
    A <- matrix(rep(0, numG * 4), nrow = numG * 2, ncol = 2)
    i <- 1
    j <- 1
    while (j < numG * 2) {
        if (rM[i, 3] != 0) {
            k <- 1
            while (k <= rM[i, 1]) {
                A[j, 1] <- i - 101
                A[j, 2] <- 1
                k <- k + 1
                j <- j + 1
            }
            k <- 1
            while (k <= (rM[i, 3] - rM[i, 1])) {
                A[j, 1] <- i - 101
                A[j, 2] <- 0
                k <- k + 1
                j <- j + 1
            }
            k <- 1
            while (k <= rM[i, 2]) {
                A[j, 1] <- i - 101
                A[j, 2] <- 0
                k <- k + 1
                j <- j + 1
            }
            k <- 1
            while (k <= (rM[i, 3] - rM[i, 2])) {
                A[j, 1] <- i - 101
                A[j, 2] <- 1
                k <- k + 1
                j <- j + 1
            }
        }
        i <- i + 1
    }
    A
}

# calculated the results of a logistic function with parameters a and b and input marg
# param marg: the specified margin of victory
# param a: the slope of the logistic regression
# param b: the intercept of the logistic regression
# returns: the result of the logstic function with those parameters, can be interpreted as "given that the home team
#        won by 'marg' number of points, what are the odds they are truely better than the away team"

logR <- function(marg, a, b) {
    return(1 / (1 + exp(-(b + a * marg))))
}

# creates a markov chain for the specified year and finds its stationary distribution
# param year: the year we are generating a markov chain for
# param a: the slope of the logistic regression
# param b: the intercept of the logistic regression
# param h: the approximate home field advantage
# return: the stationary distribution of the markov chain for that year

tMatrix <- function(year, a, b, h) {
    A <- read.csv(paste(file = "cfb_years_", year, "-schedule_schedule.csv", sep = ""),
        head = TRUE, sep = ","
    )

    teamN <- c()
    i <- 1
    while (i <= NROW(A)) {
        nameW <- getWinner(A, i)
        nameL <- getLoser(A, i)
        if (!is.element(nameW, teamN) && nameW != "Winner/Tie" && nameW != "") {
            teamN[length(teamN) + 1] <- nameW
        }
        if (!is.element(nameL, teamN) && nameL != "Loser/Tie" && nameL != "") {
            teamN[length(teamN) + 1] <- nameL
        }


        i <- i + 1
    }
    M <- matrix(rep(0, length(teamN) * length(teamN)), nrow = length(teamN), ncol = length(teamN))
    rownames(M) <- teamN
    colnames(M) <- teamN

    i <- 1
    while (as.numeric(A[i, 2]) < 16 && i <= NROW(A)) {
        nameW <- getWinner(A, i)
        nameL <- getLoser(A, i)
        if (A[i, 7] == "@") {
            HomeT <- nameL
            AwayT <- nameW
            marg <- as.numeric(A[i, 9]) - as.numeric(A[i, 6])
        } else {
            HomeT <- nameW
            AwayT <- nameL
            marg <- as.numeric(A[i, 6]) - as.numeric(A[i, 9])
        }
        # print(HomeT)
        # print(AwayT)
        if (A[i, 7] == "" || A[i, 7] == "@") {
            M[HomeT, HomeT] <- M[HomeT, HomeT] + 1
            M[AwayT, AwayT] <- M[AwayT, AwayT] + 1
            M[HomeT, AwayT] <- M[HomeT, AwayT] + 1 - logR(marg, a, b)
            M[AwayT, HomeT] <- M[AwayT, HomeT] + logR(marg, a, b)
        } else {
            M[HomeT, HomeT] <- M[HomeT, HomeT] + 1
            M[AwayT, AwayT] <- M[AwayT, AwayT] + 1
            M[HomeT, AwayT] <- M[HomeT, AwayT] + 1 - logR(marg + h, a, b)
            M[AwayT, HomeT] <- M[AwayT, HomeT] + logR(marg + h, a, b)
        }

        i <- i + 1
        if (i < NROW(A) && A[i, 2] == "Wk") {
            i <- i + 1
        }
    }
    for (team in colnames(M)) {
        stay <- 1
        N <- M[team, team]
        for (teamB in rownames(M)) {
            M[team, teamB] <- M[team, teamB] / N
            stay <- stay - M[team, teamB]
        }
        stay <- stay + 1
        M[team, team] <- stay
    }
    P <- M
    for (i in rownames(M)) {
        for (j in colnames(M)) {
            if (is.na(P[i, j])) {
                print(i)
                print(j)
                stop()
            }
        }
    }
    P <- M
    for (i in 1:400) {
        P <- P %*% M
    }
    i <- 1
    print(sort(P[1, ]))
    write.table(sort(P[1, ], decreasing = TRUE), file = paste("yearlyRankings/", year, ".csv", sep = ""), sep = ",")
    P
}

# Given two teams and the stationary distribution, finds an approximite point spread between the two teams
# param fav: the higher ranked team
# param und: the lower ranked team
# parm P: the stationary distribution of our Marcov Chain
# param C: a scalar used to approximate the point spread

# return the approximate point spread between the fav and und
pointSpread <- function(fav, und, P, C) {
    out <- tryCatch(
        {
            return((P["Alabama", fav] - P["Alabama", und]) * C)
        },
        error = function(cond) {
            return(-1000)
        }
    )
    return(out)
}

# counts the number of bowl games correctly predicted by the F-LRMC for the specified year
# param year: the year of the season we are generating a model for
# param a: the slope of the logistic regression
# param b: the intercept of the logistic regression
# param h: the approximate home field advantage
# returns: the number of bowl games correctly predicted by the F-LRMC that year

getSpreads <- function(year, a, b, h) {
    P <- tMatrix(year, a, b, h)

    A <- read.csv(paste(file = "cfb_years_", year, "-schedule_schedule.csv", sep = ""),
        head = TRUE, sep = ","
    )
    spreads <- rep(0, 43)
    j <- 1
    i <- 1
    while (i < NROW(A) && as.numeric(A[i, 2]) < 16) {
        i <- i + 1
        if (A[i, 2] == "Wk") {
            i <- i + 1
        }
    }
    while (i <= NROW(A)) {
        if (A[i, 2] == "Wk") {
            i <- i + 1
        }
        nameW <- getWinner(A, i)
        nameL <- getLoser(A, i)
        marg <- as.numeric(A[i, 6]) - as.numeric(A[i, 9])

        if (nameW != "" && nameL != "") {
            spreads[j] <- pointSpread(nameW, nameL, P, 4000)
        }
        # print(nameW)
        # print(nameL)
        # print(spreads[j])
        j <- j + 1
        i <- i + 1
    }
    # print(spreads)
    l <- 0
    for (g in spreads) {
        if (g > 0) {
            l <- l + 1
        }
    }
    l
}

#------------------------------------------------#
# To be ran before model is constructed
# Creates a "CG" (common game) csv file.
# for every game in the specified season, we look at all the other games played in that season between each of
# the teams and a common opponent. (A plays B, we find all the teams, C, such that A and B both played C in that season)
# the CG file is structrued as followed:
#    column 1: row number
#    column 2: home team name
#    column 3: away team name
#    column 4: margin of victory
#    column 5: week of the season
#    column 6: Common Game results for the home team. For every common team game, we specify whether the home team played
#            the common game opponent home or away and the margin of victory
#    column 7: Common Game results for the away team. For every common team game, we specify whether the away team played
#            the common game opponent home or away and the margin of victory
# param year: the year of the seaons we are generating the CG file for
# returns: CG table
genCG <- function(year) {
    A <- read.csv(file = paste("mhsaa_years_", (year), "-schedule_schedule.csv", sep = ""), head = TRUE, sep = ",")
    CG <- matrix(rep(0, NROW(A) * 6), nrow = NROW(A), ncol = 6)
    i <- 1
    print(A[i, 2])
    print(A[i, 2])
    while (as.numeric(A[i, 2]) < 16) {
        print(i)
        if (A[i, 7] != "N") {
            nameW <- getWinner(A, i)
            nameL <- getLoser(A, i)
            if (A[i, 7] == "@") {
                HomeT <- nameL
                AwayT <- nameW
                marg <- as.numeric(A[i, 9]) - as.numeric(A[i, 6])
            } else {
                HomeT <- nameW
                AwayT <- nameL
                marg <- marg <- as.numeric(A[i, 6]) - as.numeric(A[i, 9])
            }
            CG[i, 1] <- HomeT
            CG[i, 2] <- AwayT
            CG[i, 3] <- marg
            CG[i, 4] <- as.numeric(A[i, 2])
            CG <- CGsearch2(A, HomeT, AwayT, CG, i)
        }
        i <- i + 1
        if (A[i, 2] == "Wk") {
            i <- i + 1
        }
    }
    write.csv(CG, file = paste("CG", year, ".csv", sep = ""))
    CG
}
# Helper function for genCG.
# Finds the common game results for the given home and away team
# param A: the table of games played for a given season
# param AnameH: the home team we are performing a common game search on
# param AnameA: the away team we are performing a common game search on
# param CG: the common game table we have generated so far
# param I: the row index of the GC table we are currently writing
# returns: updated CG table
CGsearch2 <- function(A, AnameH, AnameA, CG, I) {
    homeOpp <- c()
    homeWin <- c()
    awayOpp <- c()
    awayWin <- c()
    homeS <- ""
    awayS <- ""
    i <- 1
    while (as.numeric(A[i, 2]) < 16) {
        if (A[i, 7] != "N") {
            nameW <- getWinner(A, i)
            nameL <- getLoser(A, i)
            if (A[i, 7] == "@") {
                HomeT <- nameL
                AwayT <- nameW
                marg <- as.numeric(A[i, 9]) - as.numeric(A[i, 6])
            } else {
                HomeT <- nameW
                AwayT <- nameL
                marg <- marg <- as.numeric(A[i, 6]) - as.numeric(A[i, 9])
            }
            if (AnameH == HomeT && AwayT != AnameA) {
                homeOpp[length(homeOpp) + 1] <- AwayT
                homeWin[length(homeWin) + 1] <- paste("H", toString(marg))
            } else if (AnameH == AwayT && HomeT != AnameA) {
                homeOpp[length(homeOpp) + 1] <- HomeT
                homeWin[length(homeWin) + 1] <- paste("A", toString(marg))
            }
            if (AnameA == HomeT && AwayT != AnameH) {
                awayOpp[length(awayOpp) + 1] <- AwayT
                awayWin[length(awayWin) + 1] <- paste("H", toString(marg))
            } else if (AnameA == AwayT && HomeT != AnameH) {
                awayOpp[length(awayOpp) + 1] <- HomeT
                awayWin[length(awayWin) + 1] <- paste("A", toString(marg))
            }
        }
        i <- i + 1
        print("here")
        print(A[1, 2])
        if (A[i, 2] == "Wk") {
            i <- i + 1
        }
    }
    x <- 1
    y <- 1
    while (x < length(homeOpp)) {
        while (y < length(awayOpp)) {
            if (homeOpp[x] == awayOpp[y]) {
                homeS <- paste(homeS, homeWin[x])
                awayS <- paste(awayS, awayWin[y])
            }
            y <- y + 1
        }
        x <- x + 1
        y <- 1
    }
    CG[I, 5] <- homeS
    CG[I, 6] <- awayS
    CG
}